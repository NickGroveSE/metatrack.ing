---
import Layout from '../../layouts/Layout.astro';
import HeroCompass from '../../components/DLHeroCompass.vue';
// import CompassFilters from '../../components/OWCompassFilters.vue'
import HeroList from '../../components/DLHeroList.vue'

import DLLogo from '../../assets/dl-logo.svg';

// Use process.env for server-side runtime variable
const backendUrl = process.env.BACKEND_URL || 'http://backend:8080';
console.log('Using backend URL:', backendUrl);

const { searchParams } = Astro.url;
    // "min-unix-ts": unixTimestampAWeekAgo.toString(),
    // "max-unix-ts": unixTimestampNow.toString(),

const defaults = {
    "timeframe": "168h",
    "min-badge": "91",
    "max-badge": "116",
    "min-hero-matches": "0",
    "min-hero-matches-total": "0",
    "heroes": "",
}

const finalParams = new URLSearchParams()
Object.entries(defaults).forEach(([key, defaultValue]) => {
  finalParams.set(key, searchParams.get(key) || defaultValue)
})

var response = new Response
const timeframe = finalParams.get("timeframe")
finalParams.delete("timeframe")
const timeframeHours = Number(timeframe?.replace(/h/g, ""))
const createTimeStamps = (tfh: number) => {
  const nowInMilliseconds = Date.now()

  const pastInMilliseconds = tfh * 60 * 60 * 1000

  const pastAgoInMilliseconds = nowInMilliseconds - pastInMilliseconds

  const unixTimestampNow = Math.floor(nowInMilliseconds / 1000)
  const unixTimestampPast = Math.floor(pastAgoInMilliseconds / 1000)

  return [unixTimestampNow, unixTimestampPast]
}

try {
  
  if (timeframe == "336h") {
    const [maxUnix, minUnix] = createTimeStamps(timeframeHours)

    finalParams.set("min-unix-ts", minUnix.toString())
    finalParams.set("max-unix-ts", maxUnix.toString())
  } else if (timeframe == "168h") {
    const [maxUnix, minUnix] = createTimeStamps(timeframeHours)

    finalParams.set("min-unix-ts", minUnix.toString())
    finalParams.set("max-unix-ts", maxUnix.toString())
  } else if (timeframe == "48h") {
    const [maxUnix, minUnix] = createTimeStamps(timeframeHours)

    finalParams.set("min-unix-ts", minUnix.toString())
    finalParams.set("max-unix-ts", maxUnix.toString())
  } else if (timeframe == "24h") {
    const [maxUnix, minUnix] = createTimeStamps(timeframeHours)

    finalParams.set("min-unix-ts", minUnix.toString())
    finalParams.set("max-unix-ts", maxUnix.toString())
  } else {
    const [maxUnix, minUnix] = createTimeStamps(timeframeHours)

    finalParams.set("min-unix-ts", minUnix.toString())
    finalParams.set("max-unix-ts", maxUnix.toString())
  }

  response = await fetch(`${backendUrl}/deadlock?${finalParams.toString()}`);
  
} catch(error){
  console.log(error)
}
const data = await response.json();
var checkedHeroes: any
var visualizedHeroes: any

const paramsForFilters = {
  timeframe: timeframe,
  minBadge: finalParams.get("min-badge"),
  maxBadge: finalParams.get("max-badge")
}

if (!finalParams.has("heroes") || finalParams.get("heroes") == "") {
  visualizedHeroes = data.data.slice(0, 10);
  checkedHeroes = visualizedHeroes.map((hero: { Heroes: { ID: any; }[]; }) => hero.Heroes[0].ID);
} else {
  console.log("Assigning Checked Heroes...")
  checkedHeroes = finalParams.get("heroes")?.split("~").map(Number)
  
  console.log("Assigning Visualized Heroes...")
  visualizedHeroes = data.data.filter((heroEntity: { Heroes: { ID: any; }[]; }) => 
    checkedHeroes.includes(heroEntity.Heroes[0].ID)
  )
}
---

<Layout title="DL Statistics" logo={DLLogo.src}>
  <main data-all-heroes={JSON.stringify(data.data)}>
    <button id="hero-list-button" class="hero-list-toggle-btn">
      Filters & Hero Selection
    </button>

    <div id="hero-list-container" class="container">
      <HeroList 
        class="hero-list"
        heroData={data.data} 
        setCheckedHeroes={checkedHeroes}
        queryParams={paramsForFilters}
        client:load
      />
    </div>

    <div id="hero-list-modal" class="modal">
      <div class="modal-content">
        <div class="modal-header">
          <h2>Filters & Hero Selection</h2>
          <button id="close-modal" class="close-btn">
            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
              <line x1="18" y1="6" x2="6" y2="18"></line>
              <line x1="6" y1="6" x2="18" y2="18"></line>
            </svg>
          </button>
        </div>
        <div class="modal-body">
          <HeroList 
            class="hero-list"
            id="hero-list-modal-content"
            heroData={data.data} 
            setCheckedHeroes={checkedHeroes}
            queryParams={paramsForFilters}
            client:load
          />
        </div>
      </div>
    </div>

    <div id="modal-overlay" class="modal-overlay"></div>

    <HeroCompass 
      class="container" 
      id="compass" 
      heroData={visualizedHeroes} 
      client:load
    />
  </main>
</Layout>

<style>
  main {
    padding: 2rem;
    max-width: 1000px;
    margin: 20px auto 0 auto;
    color: white;
  }

  .container {
    display: inline-block;
    vertical-align: top;
  }

  #compass {
    margin-left: 1rem;
  }

  #hero-list-container {
    vertical-align: top;
  }

  .hero-list-toggle-btn {
    display: none;
    align-items: center;
    gap: 8px;
    background-color: #fbbf24;
    color: #111827;
    border: none;
    padding: 12px 24px;
    font-size: 16px;
    font-weight: 700;
    border-radius: 8px;
    cursor: pointer;
    margin-bottom: 1rem;
    transition: all 0.3s ease;
  }

  .hero-list-toggle-btn:hover {
    background-color: #f59e0b;
    transform: translateY(-2px);
    box-shadow: 0 4px 12px rgba(251, 191, 36, 0.3);
  }

  .hero-list-toggle-btn:active {
    transform: translateY(0);
  }

  /* Modal styles */
  .modal {
    position: fixed;
    top: 0;
    left: -100%;
    width: 90%;
    max-width: 400px;
    height: 100vh;
    z-index: 1001;
    transition: left 0.3s ease;
  }

  .modal.active {
    left: 0;
  }

  .modal-content {
    background-color: #1f2937;
    height: 100%;
    display: flex;
    flex-direction: column;
    box-shadow: -4px 0 20px rgba(0, 0, 0, 0.5);
  }

  .modal-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 1.5rem;
    border-bottom: 2px solid #fbbf24;
    background-color: #111827;
  }

  .modal-header h2 {
    margin: 0;
    color: #fbbf24;
    font-size: 1.5rem;
  }

  .close-btn {
    background: none;
    border: none;
    color: #fbbf24;
    cursor: pointer;
    padding: 4px;
    display: flex;
    align-items: center;
    justify-content: center;
    transition: all 0.2s ease;
    border-radius: 4px;
  }

  .close-btn:hover {
    background-color: #374151;
    transform: rotate(90deg);
  }

  .modal-body {
    flex: 1;
    overflow-y: auto;
    padding: 1.5rem;
  }

  .modal-overlay {
    position: fixed;
    display: flex;
    justify-content: center; /* Centers horizontally */
    align-items: center;     /* Centers vertically */
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background-color: rgba(0, 0, 0, 0.6);
    opacity: 0;
    visibility: hidden;
    transition: opacity 0.3s ease, visibility 0.3s ease;
    z-index: 1000;
    font-size: 32px;
    color: white;
  }

  .modal-overlay.active {
    opacity: 1;
    visibility: visible;
  }

  /* Responsive styles */
  @media (max-width: 980px) {
    main {
      padding: 1.5rem;
    }

    .hero-list-toggle-btn {
      display: flex;
    }

    #hero-list-container {
      display: none;
    }

    .container {
      display: block;
      width: 100%;
    }

    #compass {
      margin-left: auto;
    }
  }  

  @media (max-width: 640px) {
    main {
      padding: 1rem;
    }

    .modal {
      width: 100%;
      max-width: 100%;
    }

    .hero-list-toggle-btn {
      width: 100%;
      justify-content: center;
    }
  }
</style>

<script>
  const compass = document.getElementById('compass');
  const main = document.querySelector('main');
  
  // Modal Functionality
  const heroListButton = document.getElementById('hero-list-button');
  const modal = document.getElementById('hero-list-modal');
  const modalOverlay = document.getElementById('modal-overlay');
  const closeButton = document.getElementById('close-modal');

  function openModal() {
    modal?.classList.add('active');
    modalOverlay?.classList.add('active');
    document.body.style.overflow = 'hidden';
  }

  function closeModal() {
    modal?.classList.remove('active');
    modalOverlay?.classList.remove('active');
    document.body.style.overflow = '';
  }

  heroListButton?.addEventListener('click', openModal);
  closeButton?.addEventListener('click', closeModal);
  modalOverlay?.addEventListener('click', closeModal);

  // Close modal on escape key
  document.addEventListener('keydown', (e) => {
    if (e.key === 'Escape' && modal?.classList.contains('active')) {
      closeModal();
    }
  });

  document.querySelectorAll('.hero-list').forEach(el => {

    el?.addEventListener('checked-heroes-changed', (event) => {
      const customEvent = event as CustomEvent;
      const checkedIds = customEvent.detail;
      const url = new URL(window.location.href);
      const searchParams = new URLSearchParams(url.search);
      const allHeroData = JSON.parse(main?.dataset.allHeroes || '[]');

      console.log('Checked heroes changed:', checkedIds);

      const heroesParam = checkedIds.join("~")

      if (searchParams.has("heroes")) {
        searchParams.set("heroes", heroesParam)
      } else {
        searchParams.append("heroes", heroesParam)
      }

      console.log(allHeroData)
      
      // Filter to get only checked heroes
      const filteredHeroes = allHeroData.filter((hero: { Heroes: { ID: any; }[]; }) => 
        checkedIds.includes(hero.Heroes[0].ID)
      );
      
      // Update compass with custom event
      const updateEvent = new CustomEvent('hero-data-updated', { 
        detail: filteredHeroes
      });

      window.history.pushState({}, '', `${url.pathname}?${searchParams.toString()}`);
      compass?.dispatchEvent(updateEvent);
    });

    el?.addEventListener('apply-filters', async (event) => {
      const backendUrl = window.location.hostname.includes('.ing') ? 'https://api.metatrack.ing' : 'http://localhost:8080';
      const customEvent = event as CustomEvent;
      const filters = customEvent.detail.filters;
      const checkedIds = customEvent.detail.checkedHeroes
      const url = new URL(window.location.href);
      const searchParams = new URLSearchParams(url.search);
      const timeframeHours = Number(filters.timeframe?.replace(/h/g, ""))

      console.log('Applying Filters:', filters);

      const requestParams = new URLSearchParams({
          "min-unix-ts": "",
          "max-unix-ts": "",
          "min-badge": filters.minBadge,
          "max-badge": filters.maxBadge,
          "min-hero-matches": "0",
          "min-hero-matches-total": "0"
      })

      const createTimeStamps = (tfh: number) => {
        const nowInMilliseconds = Date.now()

        const pastInMilliseconds = tfh * 60 * 60 * 1000

        const pastAgoInMilliseconds = nowInMilliseconds - pastInMilliseconds

        const unixTimestampNow = Math.floor(nowInMilliseconds / 1000)
        const unixTimestampPast = Math.floor(pastAgoInMilliseconds / 1000)

        return [unixTimestampNow, unixTimestampPast]
      }

      if (filters.timeframe == "336h") {
        const [maxUnix, minUnix] = createTimeStamps(timeframeHours)

        requestParams.set("min-unix-ts", minUnix.toString())
        requestParams.set("max-unix-ts", maxUnix.toString())
      } else if (filters.timeframe == "168h") {
        const [maxUnix, minUnix] = createTimeStamps(timeframeHours)

        requestParams.set("min-unix-ts", minUnix.toString())
        requestParams.set("max-unix-ts", maxUnix.toString())
      } else if (filters.timeframe == "48h") {
        const [maxUnix, minUnix] = createTimeStamps(timeframeHours)

        requestParams.set("min-unix-ts", minUnix.toString())
        requestParams.set("max-unix-ts", maxUnix.toString())
      } else if (filters.timeframe == "24h") {
        const [maxUnix, minUnix] = createTimeStamps(timeframeHours)

        requestParams.set("min-unix-ts", minUnix.toString())
        requestParams.set("max-unix-ts", maxUnix.toString())
      } else {
        const [maxUnix, minUnix] = createTimeStamps(timeframeHours)

        requestParams.set("min-unix-ts", minUnix.toString())
        requestParams.set("max-unix-ts", maxUnix.toString())
      }

      // Close modal after applying filters on mobile
      if (window.innerWidth <= 980) {
        closeModal();
      }

      var response = new Response()
      try {
        response = await fetch(`${backendUrl}/deadlock?${requestParams.toString()}`);
        
      } catch(error){
        console.log(error)
      }
      const data = await response.json();

      console.log(data)

      const filteredHeroes = data.data.filter((hero: { Heroes: { ID: any; }[]; }) => 
        checkedIds.includes(hero.Heroes[0].ID)
      );

      // const updatedHeroes = [...filteredHeroes, data.data];
      // const updateAllHeroes = [...allHeroData, data.data];

      const updateCompass = new CustomEvent('hero-data-updated', { 
        detail: filteredHeroes
      });

      // const updateList = new CustomEvent('hero-list-updated', {
      //   detail: updateAllHeroes
      // })

      // const heroesParam = checkedIds.join("~")

      // if (searchParams.has("heroes")) {
      //   searchParams.set("heroes", heroesParam)
      // } else {
      //   searchParams.append("heroes", heroesParam)
      // }

      Object.keys(filters).forEach(key => {
        const value = filters[key]
        if (searchParams.has(key)) {
          searchParams.set(key, value)
        } else {
          searchParams.append(key, value)
        }
      })

      window.history.pushState({}, '', `${url.pathname}?${searchParams.toString()}`);
      compass?.dispatchEvent(updateCompass);
      if (!main) {
        console.error('Main element not found');
        return;
      }

      main.dataset.allHeroes = JSON.stringify(data.data);



      // Params Dispatch needed
      // main.dataset.params = JSON.stringify({
      //   timeframe: filters.timeframe,
      //   minBadge: filters.minBadge,
      //   maxBadge: filters.maxBadge
      // })
    })

  })
  // heroList?.addEventListener('combo-added', async (event) => {
  //   const backendUrl = process.env.BACKEND_URL || 'http://localhost:8080';
  //   const customEvent = event as CustomEvent;
  //   const checkedHeroes = customEvent.detail.checkedHeroes
  //   const combosParam = customEvent.detail.combo;
  //   const url = new URL(window.location.href);
  //   const searchParams = new URLSearchParams(url.search);

  //   const nowInMilliseconds = Date.now()
  //   const weekInMilliseconds = 168 * 60 * 60 * 1000 // 168 hours * 60 minutes/hour * 60 seconds/minute * 1000 milliseconds/second

  //   const weekAgoInMilliseconds = nowInMilliseconds - weekInMilliseconds

  //   const unixTimestampNow = Math.floor(nowInMilliseconds / 1000)
  //   const unixTimestampAWeekAgo = Math.floor(weekAgoInMilliseconds / 1000)

  //   const requestParams = {
  //       "min-unix-ts": unixTimestampAWeekAgo.toString(),
  //       "max-unix-ts": unixTimestampNow.toString(),
  //       "min-badge": "91",
  //       "max-badge": "116",
  //       "min-hero-matches-total": "0",
  //       "combo": combosParam,
  //   }

  //   const newParams = new URLSearchParams()
  //   Object.entries(requestParams).forEach(([key, value]) => {
  //     newParams.set(key, value)
  //   })

  //   if (searchParams.has("combos")) {
  //     const allCombos = `${searchParams.get("combos")}~${combosParam}`
  //     searchParams.set("combos", allCombos)
  //   } else {
  //     searchParams.append("combos", combosParam)
  //   }

  //   var response = new Response()
  //   try {
  //     response = await fetch(`${backendUrl}/deadlock/combo?${newParams.toString()}`);
      
  //   } catch(error){
  //     console.log(error)
  //   }
  //   const data = await response.json();

  //   const filteredHeroes = allHeroData.filter((hero: { Heroes: { ID: any; }[]; }) => 
  //     checkedHeroes.includes(hero.Heroes[0].ID)
  //   );

  //   const updatedHeroes = [...filteredHeroes, data.data];
  //   const updateAllHeroes = [...allHeroData, data.data];

  //   const updateCompass = new CustomEvent('hero-data-updated', { 
  //     detail: updatedHeroes
  //   });

  //   const updateList = new CustomEvent('hero-list-updated', {
  //     detail: updateAllHeroes
  //   })

  //   window.history.pushState({}, '', `${url.pathname}?${searchParams.toString()}`);
  //   compass?.dispatchEvent(updateCompass);
  //   heroList.dispatchEvent(updateList);
  // })

</script>